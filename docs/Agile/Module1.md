# Agile Software Processes

## Modules 1 (Pre-recorded)

### Traditional Software Development 

#### History 

* Large Software Projects (Mainframe era)
* Development Models based on Linear Models * (Sequential/Waterfall)
* No Time-to-Market Constraints (Software is * Expensive)
* Mostly Custom/Bespoke Software Development
* Programmer-Intensive Manual Activities



#### Traditional Software Project (1990-2000)

![image](../img/Agile/Module%201%20history.png)

Most it was cancelled and failure because 
* Highly manual
* Process of gathering requirement

![image](../img/Agile/Module%201%20history%202.png)

Always used on 7%
So most of development efforts going waste


In 2009, companies and organizations in the U.S. spent  $491.2billion on application development. That means that more than $103billion was wasted on failed projects.

#### Agile Turns Upside-down Project Constraints

![image](../img/Agile/Module%201%20Reason.png)

Reason for failure in traditional project
* Scope - Expected customer will give proper requirement, in well documented manner

In Agile
* Cost and Time is fixed, cannot be compromise

### Evolution

![image](../img/Agile/Module%201%20Evolution.png)

Spiral model - where will create mulitple rotation for whole project

### What is Agile

English meaning
* Able to move quickly and easily
* Flexible

Agility
* The ability to both create and respond to change in order to profit in a turbulent business environment
    * Rigid Processes (Water fall) vs. Agile Frameworks
    * Being Agile = Competitive, Responsive, Flexible,…

<br> <i>Note: </i> 
Adopting organisation to change towards customer requirement, change in technologies

### Agile Development – A Series of Short Sprints (Difference)

![image](../img/Agile/Module%201%20Difference.png)

Waterfall - First full requirement and document, and then devlopment

Agile - In iteration way

Advantage in AGile - Risk accumulation (risk is reduce)

#### Agile Development = Iterative Releases! 


* Agile software development is a conceptual framework for software engineering  that promotes development iterations throughout the life-cycle of the project.

* Software developed during one unit of time is referred to as an iteration (sprint), which may last from one to four weeks.

* Agile methods also emphasize working software as the primary measure of progress

### Need for Agile Methods
#### Addressing Challenges of Waterfall Model

* Traditional Waterfall  Adaptations of Waterfall 
    * Focus on Requirements Management (Breaking down * into manageable ‘Increments’)
    * De-risking Large Development Effort
    * Capturing Requirements (‘show-and-tell’, * ‘prototype’ as basis of discussion around * Requirements)
    * "Quick-and-dirty" Working Prototype to Start with

Water fall model 

![image](../img/Agile/Module%201%20Water%20model.png)

Incremental model 

![image](../img/Agile/Module%201%20incremental.png)

Spiral model 

![image](../img/Agile/Module%201%20spiral.png)

<br> <i>Note: </i> 
* All this are model - requirement was frozen in begining 
* Quick-and-dirty-completing a task rapidly rather than making it high quality

#### Pace of Technology vs Project Duration

* Technology Life-cycles have shrunk (decade -> 2 * or 3 years)
* Bespoke Software -> Product Customization
* Line-by-line Coding -> Integrated Development Frameworks

![image](../img/Agile/Module%201%20Pace%20of%20technology.png)

<br> <i>Note: </i> 
* Technology changes every 2 or 3 years, we should flexible to accept it
* Bespoke - customer software development (developed for specific customer)
* Product customization - should be customisation
* Integrated Development Frameworks - low code or no code 


#### De-risking Future Investments Upfront…

* “Fail-Safe” early rather than Failure at the end
* “Proof-of-concept” when adopting new * Technologies
* “Testing the waters” before launching Big in * the Marketplace
* Today’s Software Products are strategic levers--* “Idea-driven” rather than mere automation of * manual process

<br> <i>Note: </i> 

* Fail-safe  - failing in initial level rather then last stage
* Proof of concept - poc
* testing the waters -  test in well before launching in market
* idea driven - most of lib, tools, technology is in open source
* automation
* design thinking - think from customer point of view

### Benefits of Agile Methods 

#### Controlled Development

* Agile Products are based on empirical control method – decisions based on reality
* Adjustments on-the-go by Frequent Inspections
* Transparency: Everyone involved knows what is  going in the project
* Frequent Inspection: Regular evaluation of the Product
* Adaptation: Make quick adjustments to minimize  problems later

<br> <i>Note: </i> 
* decisions based on reality-Show to customer and get feedback 

### Agile Development  Agile Project Management

* Traditional Project Management Turned Upside-down!
* “Let’s wait till the Project completes to see the Product” -> “Several Min-projects with * little visible successes” 
* Transformation of Project Management by  actively involving ALL the Stakeholders; * Organization Structures & Communication; * Time-Boxing of Deliveries

<br> <i>Note: </i> 
* In Agile project will have many mini projects
* Time-boxing - fixing deadline for each mini projects

### Benefits of Agile Project Management

* Almost Zero Risk of Catastrophic Project Failure
* Prioritization of Business Value over ‘Good or Nice-to-have’ features
* Agile Testing (Continuous Testing) ensures Problems are discovered early
* Down-plays ‘Scope-creep’ as Requirement Changes are managed throughout Product Development Life-cycle
    * Prioritizing Features in early Iterations
    * Managing Evolving Requirements
* Continuous Inspection and Adaptation: Improvement of Processes and Products based on Prior Experience of the ‘Completed’ Product 


<br> <i>Note: </i> 
* Zero risk
* Prioritize requirement (start with core feature and then nice to have feature at end)
* Continous testing (also can be implement Test driven Development - TDD)
* Scope-creep - Requirement keep on changing
* Continuous Inspection and Adaptation - like 
Sprint Retrospective- lesson learnt from previous sprint (what went well, what could have been improved and action)


### Agile methods - summary

* Traditional Software Development Methods involving Large One-time Projects are yielding to Low-risk High-turnaround Incremental Deliverables in Agile Methods
* Involvement of All Stakeholders (including Customer) early on in the Process enhances Collaboration and minimizes Scope-creep
* Full Transparency and High-visibility of Deliverables in Short Iterations (Sprints)
* Continuous Quality Monitoring with embedded Agile Testing across all Iterations

“Agile is the Great Leap Forward in Software Development Methodology with its associated Transformation in Agile Project Management”


